/**
 * Collections API
 * GET /api/collections - Get user's collections
 * POST /api/collections - Create a new collection
 *
 * Task 1.9: Collection Creation API
 * Task 1.10: Collection List UI
 */

import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createCollectionSchema } from '@/lib/validations/collections';
import { searchWithReranking } from '@/lib/search';
import { createFileSearchStore } from '@/lib/gemini/fileSearch';
import { queuePdfDownload } from '@/lib/jobs/queues';
import {
  createCollection,
  updateCollectionFileSearchStore,
  linkPapersToCollection,
  getUserCollections,
} from '@/lib/db/collections';
import {
  semanticScholarPaperToDbPaper,
  upsertPapers,
  getOpenAccessPapers,
} from '@/lib/db/papers';

/**
 * GET /api/collections
 * Get user's collections with paper counts
 */
export async function GET() {
  try {
    // Authenticate user
    const supabase = await createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get user's collections
    const collections = await getUserCollections(supabase, user.id);

    return NextResponse.json({
      success: true,
      data: {
        collections,
      },
    });
  } catch (error) {
    console.error('Error fetching collections:', error);
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';

    return NextResponse.json(
      {
        error: 'Failed to fetch collections',
        message: errorMessage,
      },
      { status: 500 }
    );
  }
}

/**
 * POST /api/collections
 * Create a new collection with papers from Semantic Scholar
 */
export async function POST(request: NextRequest) {
  try {
    // 1. Parse and validate request body
    const body = await request.json();
    const result = createCollectionSchema.safeParse(body);

    if (!result.success) {
      console.error('Validation failed:', result.error);
      const errors = result.error.issues || [];

      return NextResponse.json(
        {
          error: 'Invalid input',
          details: errors.map(e => ({
            field: e.path.join('.'),
            message: e.message,
          })),
        },
        { status: 400 }
      );
    }

    const validatedData = result.data;

    // 2. Authenticate user
    const supabase = await createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // 3. Determine keywords to use
    // For AI-assisted mode, keywords should have been generated by frontend
    // For manual mode, use keywords directly
    const keywords = validatedData.keywords!; // Validation ensures this is present

    // 4. Search papers with semantic re-ranking
    // Use TEST_PAPER_LIMIT in test environment to reduce paper count for faster tests
    const paperLimit = process.env.TEST_PAPER_LIMIT
      ? parseInt(process.env.TEST_PAPER_LIMIT, 10)
      : 100; // Default limit for final collection

    // Use naturalLanguageQuery for embedding, fallback to keywords
    const userQuery = validatedData.naturalLanguageQuery || keywords;

    console.log('[CollectionAPI] Using semantic re-ranking search');

    const searchResult = await searchWithReranking({
      userQuery,
      searchKeywords: keywords,
      initialLimit: 500, // Fetch more papers for re-ranking
      finalLimit: paperLimit,
      yearFrom: validatedData.filters?.yearFrom,
      yearTo: validatedData.filters?.yearTo,
      minCitations: validatedData.filters?.minCitations,
      openAccessOnly: validatedData.filters?.openAccessOnly,
    });

    const papers = searchResult.papers;

    // 5. Handle empty search results
    if (papers.length === 0) {
      return NextResponse.json(
        {
          error:
            'No papers found matching your criteria. Try different keywords or adjust your filters.',
        },
        { status: 404 }
      );
    }

    console.log(`[CollectionAPI] Found ${papers.length} papers`);

    // 6. Create collection in database
    const collection = await createCollection(supabase, {
      name: validatedData.name,
      search_query: keywords,
      filters: validatedData.filters || null,
      user_id: user.id,
      use_ai_assistant: validatedData.useAiAssistant || false,
      natural_language_query: validatedData.naturalLanguageQuery || null,
    });

    // 6. Upsert papers to database
    const dbPapers = papers.map(semanticScholarPaperToDbPaper);
    const upsertedPaperIds = await upsertPapers(supabase, dbPapers);

    // 7. Link papers to collection via collection_papers
    await linkPapersToCollection(supabase, collection.id, upsertedPaperIds);

    // 8. Create Gemini File Search Store
    const storeResult = await createFileSearchStore(
      collection.id,
      `${validatedData.name} - ${collection.id.substring(0, 8)}`
    );

    if (!storeResult.success || !storeResult.storeId) {
      console.error('Failed to create File Search Store:', storeResult.error);
      // Don't fail the entire request, store can be created later
      // Log error and continue
    } else {
      // 9. Update collection with file_search_store_id
      await updateCollectionFileSearchStore(
        supabase,
        collection.id,
        storeResult.storeId
      );
    }

    // 10. Queue PDF download jobs for Open Access papers
    const openAccessPapers = getOpenAccessPapers(papers);
    const queuedJobs: (string | null)[] = [];

    for (const paper of openAccessPapers) {
      if (!paper.openAccessPdf?.url) continue;

      const jobId = await queuePdfDownload({
        collectionId: collection.id,
        paperId: paper.paperId,
        pdfUrl: paper.openAccessPdf.url,
      });

      queuedJobs.push(jobId);
    }

    const successfulJobs = queuedJobs.filter(id => id !== null).length;

    // 11. Return success response
    return NextResponse.json(
      {
        success: true,
        data: {
          collection: {
            id: collection.id,
            name: collection.name,
            searchQuery: collection.search_query,
            filters: collection.filters,
            fileSearchStoreId: storeResult.storeId || null,
            createdAt: collection.created_at,
          },
          stats: {
            totalPapers: papers.length,
            openAccessPapers: openAccessPapers.length,
            queuedDownloads: successfulJobs,
            failedToQueue: queuedJobs.length - successfulJobs,
            // Re-ranking statistics
            reranking: {
              totalSearched: searchResult.stats.totalSearched,
              papersWithEmbeddings: searchResult.stats.papersWithEmbeddings,
              rerankingApplied: searchResult.stats.rerankingApplied,
            },
          },
        },
      },
      { status: 201 }
    );
  } catch (error) {
    // Handle errors
    console.error('Error creating collection:', error);
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';

    return NextResponse.json(
      {
        error: 'Failed to create collection',
        message: errorMessage,
      },
      { status: 500 }
    );
  }
}
